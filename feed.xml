<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://jeimon.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://jeimon.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-09-17T09:52:44+00:00</updated><id>https://jeimon.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Some Notes about Linux LSM</title><link href="https://jeimon.github.io/blog/2019/linux-lsm/" rel="alternate" type="text/html" title="Some Notes about Linux LSM"/><published>2019-11-08T00:00:00+00:00</published><updated>2019-11-08T00:00:00+00:00</updated><id>https://jeimon.github.io/blog/2019/linux-lsm</id><content type="html" xml:base="https://jeimon.github.io/blog/2019/linux-lsm/"><![CDATA[<h2 id="discretionary-access-control">Discretionary Access Control</h2> <p>Linux was initially developed as a clone of the Unix operating system in the early 1990s. As such, it inherits the core Unix security model—a form of Discretionary Access Control (DAC). The security features of the Linux kernel have evolved significantly to meet modern requirements, although Unix DAC remains as the core model.</p> <p>Briefly, Unix DAC allows the owner of an object (such as a file) to set the security policy for that object—which is why it’s called a discretionary scheme. As a user, you can, for example, create a new file in your home directory and decide who else may read or write the file. This policy is implemented as permission bits attached to the file’s inode, which may be set by the owner of the file. Permissions for accessing the file, such as read and write, may be set separately for the owner, a specific group, and other (i.e. everyone else). This is a relatively simple form of access control lists (ACLs).</p> <p>Programs launched by a user run with all of the rights of that user, whether they need them or not. There is also a superuser—an all-powerful entity which bypasses Unix DAC policy for the purpose of managing the system. Running a program as the superuser provides that program with all rights on the system.</p> <p>However DAC does not adequately protect against buggy or misconfigured software, for example, which may be exploited by an attacker seeking unauthorized access to resources. There are all kinds of Linux security extensions, we just dicuss the Linux Security Modules and we will take the SELinux as an example to see how it works. ( If you want to see more information about the overview of Linux kernel security features, <a href="https://www.linux.com/learn/overview-linux-kernel-security-features">click here</a>).</p> <h2 id="linux-security-modules">Linux Security Modules</h2> <p>The Linux Security Modules (LSM) API implements hooks at all security-critical points within the kernel. A user of the framework (an “LSM”) can register with the API and receive callbacks from these hooks. All security-relevant information is safely passed to the LSM, avoiding race conditions, and the LSM may deny the operation. This is similar to the Netfilter hook-based API, although applied to the general kernel.</p> <p>The LSM API allows different security models to be plugged into the kernel—typically access control frameworks, such as SELinux, AppArmor, Smack and so on. In other words, we have 190 security-critical check points whose implementations are customized by user. For each point, we can plug one or more check implementations (access control frameworks). To ensure compatibility with existing applications, the LSM hooks are placed so that the Unix DAC checks are performed first, and only if they succeed, is LSM code invoked.</p> <p>And all security hooks are initialized in security/security.c. We use one simple security-critical check point for example, <a href="https://elixir.bootlin.com/linux/v4.18.5/source/security/security.c#L887"><code class="language-plaintext highlighter-rouge">security_file_ioctl</code></a>, and figure out how it works:</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">security_file_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="nc">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">call_int_hook</span><span class="p">(</span><span class="n">file_ioctl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>It uses <a href="https://elixir.bootlin.com/linux/v4.18.5/source/security/security.c#L214"><code class="language-plaintext highlighter-rouge">call_int_hook</code></a> macro to initialize.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define call_int_hook(FUNC, IRC, ...) ({			\  
</span>	<span class="kt">int</span> <span class="n">RC</span> <span class="o">=</span> <span class="n">IRC</span><span class="p">;</span>						\
	<span class="k">do</span> <span class="p">{</span>							\
		<span class="k">struct</span> <span class="nc">security_hook_list</span> <span class="o">*</span><span class="n">P</span><span class="p">;</span>			\
								\
		<span class="n">hlist_for_each_entry</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">security_hook_heads</span><span class="p">.</span><span class="n">FUNC</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span> \
			<span class="n">RC</span> <span class="o">=</span> <span class="n">P</span><span class="o">-&gt;</span><span class="n">hook</span><span class="p">.</span><span class="n">FUNC</span><span class="p">(</span><span class="n">__VA_ARGS__</span><span class="p">);</span>		\
			<span class="k">if</span> <span class="p">(</span><span class="n">RC</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>				\
				<span class="k">break</span><span class="p">;</span>				\
		<span class="p">}</span>						\
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>						\
	<span class="n">RC</span><span class="p">;</span>							\
<span class="p">})</span>
</code></pre></div></div> <p>Then call_int_hook use hlist_for_each_entry ( a loop as following) macro to go through all the check implementations at the check point “security_hook_heads.FUNC”.</p> <p>Then <a href="https://elixir.bootlin.com/linux/v4.18.5/source/security/security.c#L214"><code class="language-plaintext highlighter-rouge">call_int_hook</code></a> use <a href="https://elixir.bootlin.com/linux/v4.18.5/source/include/linux/list.h#L754"><code class="language-plaintext highlighter-rouge">hlist_for_each_entry</code></a> (a loop as following) macro to go through all the check implementations at the check point “<a href="https://elixir.bootlin.com/linux/v4.18.5/source/include/linux/lsm_hooks.h#L1777"><code class="language-plaintext highlighter-rouge">security_hook_heads</code></a>.FUNC”.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */</span>
<span class="cp">#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)-&gt;first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)-&gt;member.next, typeof(*(pos)), member))
</span><span class="k">struct</span> <span class="nc">security_hook_heads</span> <span class="p">{</span>
<span class="p">...</span>
	<span class="k">struct</span> <span class="nc">hlist_head</span> <span class="n">file_permission</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">hlist_head</span> <span class="n">file_alloc_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">hlist_head</span> <span class="n">file_free_security</span><span class="p">;</span>
	<span class="k">struct</span> <span class="nc">hlist_head</span> <span class="n">file_ioctl</span><span class="p">;</span>
	<span class="p">...</span>
<span class="p">}</span> <span class="n">__randomize_layout</span><span class="p">;</span>
</code></pre></div></div> <p>We can find <code class="language-plaintext highlighter-rouge">struct hlist_head file_ioctl</code> is inside the <code class="language-plaintext highlighter-rouge">security_hook_heads</code> which is indexed by <code class="language-plaintext highlighter-rouge">FUNC</code>. <a href="https://elixir.bootlin.com/linux/v4.18.5/source/include/linux/lsm_hooks.h#L1777"><code class="language-plaintext highlighter-rouge">security_hook_heads</code></a> is consisted of several <code class="language-plaintext highlighter-rouge">struct hlist_head</code> type variable which is a two-way linked-list data structure that links different kinds of check implements needed. It can be understood better by showing the figure as follow:</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/lsm-480.webp 480w,/assets/img/lsm-800.webp 800w,/assets/img/lsm-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/lsm.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> Figure 1: assuming firstly do SELinux check, secondly do AppArmor check and then other checks. </div> <p>All the different access control frameworks use <code class="language-plaintext highlighter-rouge">LSM_HOOK_INIT</code> to add their check implementations, let us see how SELinux do it.</p> <div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="nc">security_hook_list</span> <span class="n">selinux_hooks</span><span class="p">[]</span> <span class="n">__lsm_ro_after_init</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">...</span>
	<span class="n">LSM_HOOK_INIT</span><span class="p">(</span><span class="n">file_permission</span><span class="p">,</span> <span class="n">selinux_file_permission</span><span class="p">),</span>
	<span class="n">LSM_HOOK_INIT</span><span class="p">(</span><span class="n">file_alloc_security</span><span class="p">,</span> <span class="n">selinux_file_alloc_security</span><span class="p">),</span>
	<span class="n">LSM_HOOK_INIT</span><span class="p">(</span><span class="n">file_ioctl</span><span class="p">,</span> <span class="n">selinux_file_ioctl</span><span class="p">),</span>
	<span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="linux-kernel"/><category term="kernel"/><category term="security"/><summary type="html"><![CDATA[Kernel version is v4.18.5.]]></summary></entry></feed>