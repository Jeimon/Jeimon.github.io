---
layout: post
title: Some Notes about Linux LSM
date: 2019-11-08
description: Kernel version is v4.18.5.
tags: kernel security
categories: linux-kernel
featured: true
---

## Discretionary Access Control

Linux was initially developed as a clone of the Unix operating system in the early 1990s. As such, it inherits the core Unix security model—a form of Discretionary Access Control (DAC). The security features of the Linux kernel have evolved significantly to meet modern requirements, although Unix DAC remains as the core model.

Briefly, Unix DAC allows the owner of an object (such as a file) to set the security policy for that object—which is why it’s called a discretionary scheme. As a user, you can, for example, create a new file in your home directory and decide who else may read or write the file. This policy is implemented as permission bits attached to the file’s inode, which may be set by the owner of the file. Permissions for accessing the file, such as read and write, may be set separately for the owner, a specific group, and other (i.e. everyone else). This is a relatively simple form of access control lists (ACLs).

Programs launched by a user run with all of the rights of that user, whether they need them or not. There is also a superuser—an all-powerful entity which bypasses Unix DAC policy for the purpose of managing the system. Running a program as the superuser provides that program with all rights on the system.

However DAC does not adequately protect against buggy or misconfigured software, for example, which may be exploited by an attacker seeking unauthorized access to resources. There are all kinds of Linux security extensions, we just dicuss the Linux Security Modules and we will take the SELinux as an example to see how it works. ( If you want to see more information about the overview of Linux kernel security features, [click here](https://www.linux.com/learn/overview-linux-kernel-security-features)).

## Linux Security Modules

The Linux Security Modules (LSM) API implements hooks at all security-critical points within the kernel. A user of the framework (an “LSM”) can register with the API and receive callbacks from these hooks. All security-relevant information is safely passed to the LSM, avoiding race conditions, and the LSM may deny the operation. This is similar to the Netfilter hook-based API, although applied to the general kernel.

The LSM API allows different security models to be plugged into the kernel—typically access control frameworks, such as SELinux, AppArmor, Smack and so on. In other words, we have 190 security-critical check points whose implementations are customized by user. For each point, we can plug one or more check implementations (access control frameworks). To ensure compatibility with existing applications, the LSM hooks are placed so that the Unix DAC checks are performed first, and only if they succeed, is LSM code invoked.

And all security hooks are initialized in security/security.c. We use one simple security-critical check point for example, [`security_file_ioctl`](https://elixir.bootlin.com/linux/v4.18.5/source/security/security.c#L887), and figure out how it works:

```c++
int security_file_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
	return call_int_hook(file_ioctl, 0, file, cmd, arg);
}
```

It uses [`call_int_hook`](https://elixir.bootlin.com/linux/v4.18.5/source/security/security.c#L214) macro to initialize.

```c++
#define call_int_hook(FUNC, IRC, ...) ({			\  
	int RC = IRC;						\
	do {							\
		struct security_hook_list *P;			\
								\
		hlist_for_each_entry(P, &security_hook_heads.FUNC, list) { \
			RC = P->hook.FUNC(__VA_ARGS__);		\
			if (RC != 0)				\
				break;				\
		}						\
	} while (0);						\
	RC;							\
})
```

Then call_int_hook use hlist_for_each_entry ( a loop as following) macro to go through all the check implementations at the check point “security_hook_heads.FUNC”.


Then [`call_int_hook`](https://elixir.bootlin.com/linux/v4.18.5/source/security/security.c#L214) use [`hlist_for_each_entry`](https://elixir.bootlin.com/linux/v4.18.5/source/include/linux/list.h#L754) (a loop as following) macro to go through all the check implementations at the check point “[`security_hook_heads`](https://elixir.bootlin.com/linux/v4.18.5/source/include/linux/lsm_hooks.h#L1777).FUNC”.


```c++
/**
 * hlist_for_each_entry	- iterate over list of given type
 * @pos:	the type * to use as a loop cursor.
 * @head:	the head for your list.
 * @member:	the name of the hlist_node within the struct.
 */
#define hlist_for_each_entry(pos, head, member)				\
	for (pos = hlist_entry_safe((head)->first, typeof(*(pos)), member);\
	     pos;							\
	     pos = hlist_entry_safe((pos)->member.next, typeof(*(pos)), member))
struct security_hook_heads {
...
	struct hlist_head file_permission;
	struct hlist_head file_alloc_security;
	struct hlist_head file_free_security;
	struct hlist_head file_ioctl;
	...
} __randomize_layout;
```

We can find `struct hlist_head file_ioctl` is inside the `security_hook_heads` which is indexed by `FUNC`. [`security_hook_heads`](https://elixir.bootlin.com/linux/v4.18.5/source/include/linux/lsm_hooks.h#L1777) is consisted of several `struct hlist_head` type variable which is a two-way linked-list data structure that links different kinds of check implements needed. It can be understood better by showing the figure as follow:

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/lsm.png" class="img-fluid rounded z-depth-1" %}
    </div>
</div>
<div class="caption">
    Figure 1: assuming firstly do SELinux check, secondly do AppArmor check and then other checks.
</div>


All the different access control frameworks use `LSM_HOOK_INIT` to add their check implementations, let us see how SELinux do it.

```c++
static struct security_hook_list selinux_hooks[] __lsm_ro_after_init = {
...
	LSM_HOOK_INIT(file_permission, selinux_file_permission),
	LSM_HOOK_INIT(file_alloc_security, selinux_file_alloc_security),
	LSM_HOOK_INIT(file_ioctl, selinux_file_ioctl),
	...
};
```